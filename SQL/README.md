[SQL solution](https://leetcode.com/problem-list/database/)

---

[1.sql-파싱과-최적화](#📘-1-sql-파싱과-최적화)
[2.인덱스-기본](#📘-2-인덱스-기본)

## 📘 1. SQL 파싱과 최적화

DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 **SQL 최적화**라고 해.

---

#### 최적화 과정은 어떻게 되는데?

> 자 우리 세분화를 해보자.

### 🔹 1. SQL 파싱

사용자로부터 SQL을 전달받으면 가장 먼저 **SQL 파서**가 **파싱**을 진행하게 돼.

> Q. 그러면 SQL 파싱이 뭐야?
> A. SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리를 생성해.
> 그 다음에 문법적으로 오류가 없는지 확인`(Syntax)`하고, 의미상 오류가 없는지 확인`(Semantic)`하는거야.
> 즉, **파싱 트리 생성 → Syntax 체크 → Semantic 체크** 순서로 진행되는거지.

---

### 🔹 1.2 SQL 최적화

파싱이 끝나면, **SQL 옵티마이저(Optimizer)**가 **SQL 최적화**를 진행해.

> Q. SQL 옵티마이저가 뭐야?
> A. 아 그거는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다행한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택하는거지.
> 즉, **DB 성능을 결정하는 가장 핵심적인 엔진 역할**이야.

---

### 🔹 1.3 로우 소스 생성

SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 변환하는 단계야.
**로우 소스 생성기(Row Source Generator)**가 그 역할을 맡아.

---

## 📘 2. 인덱스 기본

---

### 2.1 인덱스 구조 및 탐색

인덱스 탐색은 **수직적 탐색**과 **수평적 탐색**, 두 단계로 나뉘어.

> SQL 튜닝은 **랜덤 Input/Output(이하 I/O)**와의 전쟁이야.
> DB 성능이 느린 이유는 **디스크 I/O** 때문이야. 왜냐하면 읽어야 할 데이터량이 많은데 그 과정에 디스크 I/O가 많이 발생할 때 느려져.
> 인덱스를 많이 사용하는 **OLTP 시스템**이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요해.

#### Q. OLTP가 뭐야?

> A. Online Transcation Processing의 줄임말로 온라인 거래 처리 시스템을 의미해.
> 사용자의 실시간 데이터 처리를 중심으로 설계된 DB 시스템 또는 응용 프로그램을 말해
> 특징으로는 짧고 빈번한 트랜잭션과 즉각적인 응답 속도 요구, 정규화된 DB 구조 사용, 데이터의 정확성과 무결성이 매우 중요해. 또한, 동시성 처리가 매우 중요해.

> 추가로 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해서 개발된 거 알아?
> IOT, 클러스터, 파티션에서부터, Prefetch, Batch I/O처럼 숨은 기능과 소트머지 조인, 해시 조인 메소드 같은 것도 결국 랜덤 I/O를 극복하기 위해서 개발된 기능인 만큼 랜덤 I/O가 매우 중요해.

#### 📍 인덱스 탐색 2단계

| 단계            | 설명                           |
| --------------- | ------------------------------ |
| **수직적 탐색** | 인덱스 스캔 **시작 지점 찾기** |
| **수평적 탐색** | 조건에 맞는 **데이터 찾기**    |

---

### 🔹 2.2 인덱스 기본 사용법

- 인덱스 기본 사용법은 인덱스를 Range Scan 하는 방법을 의미해.

인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있어.

#### Q. 왜 인덱스를 가공하면 사용이 안돼?

> A. 먼저, 정상적으로 사용한다는 것은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미해.
> **인덱스 컬럼을 함수/연산 등으로 가공하면** 인덱스의 정렬 구조를 사용할 수 없게 돼.
> 사용은 할 수 있지만, **스캔 시작점을 찾을 수 없어** 결국 리프 블록 전체를 스캔하게 되는거지.
> 즉, **Index Full Scan** 방식으로 작동하게 되는거고, 결국 성능이 떨어지기 때문에 튜닝의 효과는 사라져.

- '인덱스 칼럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.' 라는 말은 공부하면서 들어봤지? 이유는 앞서 설명한 것과 같아.
  왜 그러는지 이유를 잘 모르고 '아 저렇구나' 라고만 알고 있는 경우가 많은데
  > 그 이유는 `인덱스 스캔 시작점을 찾을 수 없기 때문`이야. 함수, 연산, 가공이 들어가면 인덱스 구조의 정렬성이 상실되서 결국에는 Index Full Scan이 적용돼.
